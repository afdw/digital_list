\documentclass{article}
\usepackage[a4paper, total={19cm, 26cm}]{geometry}
\usepackage[pdfusetitle]{hyperref}
\usepackage{url}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage[backend=biber, style=alphabetic, sorting=none]{biblatex}
\addbibresource{main.bib}
\nocite{*}
\usepackage[usenames, dvipsnames, svgnames, x11names]{xcolor}
\usepackage{graphics}
\usepackage{scalerel}
\usepackage{accsupp}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{lstcoq}
\usepackage{tikz}
\usetikzlibrary{matrix}
\usetikzlibrary{arrows.meta}
\tikzstyle{node_matrix} = [matrix of nodes, nodes in empty cells, nodes = {anchor = center, minimum size = 20, draw, fill = blue!10}, anchor = west]
\tikzstyle{arrow} = [[-{>[length=7, width=5]}]
\tikzstyle{leaf_tree} = [level distance = 25, level 1/.style = {sibling distance = 40}, level 2/.style = {sibling distance = 20}]
\tikzstyle{leaf_tree_leaf} = [minimum size = 0, circle, draw]
\tikzstyle{leaf_tree_inner_node} = [minimum size = 0, circle, draw, inner sep = 1, fill = black]
\newcommand{\bigvarnothing}[0]{%
    \scalebox{3}{%
        \begin{tikzpicture}%
            \clip (-0.114, -0.1) rectangle (0.114, 0.128);
            \node [style = {inner sep = 0}, text = black!35] {$\varnothing$};
        \end{tikzpicture}%
    }%
}
\newcommand{\completebinaryleaftreedepthzero}[1]{%
    \begin{tikzpicture}%
        \begin{scope} [leaf_tree]
            \node [style = {leaf_tree_leaf}] {#1};
        \end{scope}
    \end{tikzpicture}%
}
\newcommand{\completebinaryleaftreedepthone}[2]{%
    \begin{tikzpicture}%
        \begin{scope} [leaf_tree]
            \node [style = {leaf_tree_inner_node}] {}
                child {
                    node [style = {leaf_tree_leaf}] {#1}
                }
                child {
                    node [style = {leaf_tree_leaf}] {#2}
                };
        \end{scope}
    \end{tikzpicture}%
}
\newcommand{\completebinaryleaftreedepthtwo}[4]{%
    \begin{tikzpicture}%
        \begin{scope} [leaf_tree]
            \node [style = {leaf_tree_inner_node}] {}
                child {
                    node [style = {leaf_tree_inner_node}] {}
                    child {
                        node [style = {leaf_tree_leaf}] {#1}
                    }
                    child {
                        node [style = {leaf_tree_leaf}] {#2}
                    }
                }
                child {
                    node [style = {leaf_tree_inner_node}] {}
                    child {
                        node [style = {leaf_tree_leaf}] {#3}
                    }
                    child {
                        node [style = {leaf_tree_leaf}] {#4}
                    }
                };
        \end{scope}
    \end{tikzpicture}%
}
\newenvironment{no_space_center}
    {\parskip=0pt\par\nopagebreak\centering}
    {\par\noindent\ignorespacesafterend}
\newenvironment{no_padding_center}
    {\parskip=0pt\par\nopagebreak\centering}
    {\par\noindent}
\newcommand*{\llbrace}{%
    \BeginAccSupp{method=hex,unicode,ActualText=2983}%
    \textnormal{\usefont{OMS}{lmr}{m}{n}\char102}%
    \mathchoice{\mkern-4.05mu}{\mkern-4.05mu}{\mkern-4.3mu}{\mkern-4.8mu}%
    \textnormal{\usefont{OMS}{lmr}{m}{n}\char106}%
    \EndAccSupp{}%
}
\newcommand*{\rrbrace}{%
    \BeginAccSupp{method=hex,unicode,ActualText=2984}%
    \textnormal{\usefont{OMS}{lmr}{m}{n}\char106}%
    \mathchoice{\mkern-4.05mu}{\mkern-4.05mu}{\mkern-4.3mu}{\mkern-4.8mu}%
    \textnormal{\usefont{OMS}{lmr}{m}{n}\char103}%
    \EndAccSupp{}%
}
\newsavebox{\lXbrace}
\savebox{\lXbrace}{$\llbrace$}
\newsavebox{\rXbrace}
\savebox{\rXbrace}{$\rrbrace$}
\def\lxbrace{\scalerel*{\usebox{\lXbrace}}{\llbrace}}
\def\rxbrace{\scalerel*{\usebox{\rXbrace}}{\rrbrace}}
\newcommand{\xbraces}[1]{\scalerel[1.5ex]{\lxbrace}{#1}\scalerel*[1.5ex]{\rxbrace}{#1}}
\title{Implementation and verification of a data structure using dependent types}
\author{Anton Danilkin}
\begin{document}

\begin{no_space_center}
    \begin{minipage}{10cm}
        \maketitle
    \end{minipage}
\end{no_space_center}

\begin{abstract}
    
\end{abstract}

\vspace{10cm}

\section{Introduction}

One of the most important data structures in functional programming are singly linked lists, which support prepending an element in the beginning, as well as destructing a non-empty list into its head (the first element) and tail (the list containing the rest of elements). Conversely, arrays are frequently used in imperative programming; they support getting and setting an element by its index, as well as, in case of vectors, dynamic resizing.

The problem of lists is that the operation of retrieving or updating an element at a specific index has linear spacial complexity in term of the size. On the flip side, operations on arrays and vectors mutate the instance they work on, which not only makes reasoning about program behavior harder, but also means that older versions of the data structure become unaccessible for future use. One way to fix that would be making a copy before each operation, but that again would mean that everything would have linear complexity.

For these reasons, the following question arises: is it possible to have a data structure that combines the benefits of singly linked lists and vectors?

\section{Similarities between numbers and lists}

Here are some standard definitions of Peano natural numbers and lists, as well as operations on them in Coq:

\begin{no_padding_center}
    \begin{tabular}{c c}
        \begin{coq}
Inductive nat :=
  | O : nat
  | S : nat -> nat.




Definition pred (n : nat) : nat :=
  match n with
  | O => O
  | S n' => n'
  end.

Fixpoint plus (n1 n2 : nat) : nat :=
  match n1 with
  | O => n2
  | S n1' => S (plus n1' n2)
  end.
        \end{coq} &
        \begin{coq}
Inductive list A :=
  | nil : list A
  | cons : A -> list A -> list A.

Arguments nil {A}.
Arguments cons {A} x l.

Definition tl {A} (l : list A) : list A :=
  match l with
  | nil => nil
  | cons _ l' => l'
  end.

Fixpoint app {A} (l1 l2 : list A) : list A :=
  match l1 with
  | nil => l2
  | cons x l1' => cons x (app l1' l2)
  end.
        \end{coq}
    \end{tabular}
\end{no_padding_center}

As remarked by Chris Okasaki \cite{okasaki_1998}, there is a clear resemblance between them: the only real difference is that \coqinline{list A} holds a datum of type \coqinline{A}, where as \coqinline{nat} does not. Here is how the list \coqinline{[7; 5; 8]} and the number 3 (which is the length of the list) could be represented:

\begin{no_padding_center}
    \begin{tikzpicture}
        \matrix (node1) [node_matrix] at (0, 0) {
            \coqinlinelight{cons} &
            7 &
            \\
        };
        \matrix (node2) [node_matrix] at (3, 0) {
            \coqinlinelight{cons} &
            5 &
            \\
        };
        \matrix (node3) [node_matrix] at (6, 0) {
            \coqinlinelight{cons} &
            8 &
            \\
        };
        \matrix (node4) [node_matrix] at (9, 0) {
            \coqinlinelight{nil} \\
        };
        \draw [arrow] (node1-1-3.center) to (node2-1-1);
        \draw [arrow] (node2-1-3.center) to (node3-1-1);
        \draw [arrow] (node3-1-3.center) to (node4-1-1);
    \end{tikzpicture}

    \begin{tikzpicture}
        \matrix (node1) [node_matrix] at (0, 0) {
            \coqinlinelight{S} &
            \\
        };
        \matrix (node2) [node_matrix] at (3, 0) {
            \coqinlinelight{S} &
            \\
        };
        \matrix (node3) [node_matrix] at (6, 0) {
            \coqinlinelight{S} &
            \\
        };
        \matrix (node4) [node_matrix] at (9, 0) {
            \coqinlinelight{O} \\
        };
        \draw [arrow] (node1-1-2.center) to (node2-1-1);
        \draw [arrow] (node2-1-2.center) to (node3-1-1);
        \draw [arrow] (node3-1-2.center) to (node4-1-1);
    \end{tikzpicture}
\end{no_padding_center}

In fact, we can go from a list to the corresponding natural number by getting its length, and back from a natural number to one of the corresponding lists by repeating an element that many times:

\begin{no_padding_center}
    \begin{tabular}{c c}
        \begin{coq}
Fixpoint length {A} (l : list A) : nat :=
  match l with
  | nil => O
  | cons _ l' => S (length l')
  end.
        \end{coq} &
        \begin{coq}
Fixpoint repeat {A} (x : A) (n : nat) : list A :=
  match n with
  | O => nil
  | S n' => cons x (repeat x n')
  end.
        \end{coq}
    \end{tabular}
\end{no_padding_center}

\section{Binary version}

As there are many ways to represent natural numbers (and not only the unary system that was considered above). Depending on which representation we chose, operations on the numbers (such as increment, decrement, sum, converting into other representations) will have different efficiency, and in each case we can find an analogous data structure.

So another simple representation of natural numbers is the binary numeral system. As seen, again, by Chris Okasaki \cite{okasaki_1998}, we can augment it to contain pieces of data by complete binary leaf trees in each digit of the number (although here we will use big-endian digit ordering instead of little-endian).

For the following, we will fix a data type \coqinline{A}. A ``complete binary leaf tree'' of depth $d$ has $2^d$ leaves where it stores values of type \coqinline{A}. Here is an example of a complete binary leaf tree of depth $2$ holding values $0$, $1$, $2$, $3$.

\begin{no_padding_center}
    \completebinaryleaftreedepthtwo{$0$}{$1$}{$2$}{$3$}
\end{no_padding_center}

We know that for each natural number $n$ there are $d \in \mathbb{N}$ and $n_{d - 1}, n_{d - 2}, ..., n_0, n_1 \in \{0, 1\}$ such that $n = n_{d - 1} 2^{d - 1} + n_{d - 2} 2^{d - 2} + ... + n_1 2^1 + n_0 2^0$. A ``digital list'' of depth $d$ is a list of length $d$ of which the $k$'th element is a complete binary leaf tree of depth $k$ if $n_k = 1$ and nothing otherwise. A ``concrete digital list'' is a $d \in \mathbb{N}$ and a digital list of depth $d$.

Here is an example of a digit list for $n = 5$, so $d = 3$, $n_2$ = 1, $n_1 = 0$, $n_2 = 1$, which stores values 0, 1, 2, 3, 4.

\begin{no_padding_center}
    \begin{tikzpicture}
        \matrix (node1) [node_matrix, nodes = {minimum height = 70}] at (0, 0) {
            \node (node1-1-1) [align = left] {\coqinlinelight{Digital} \\ \coqinlinelight{List} \\ \coqinlinelight{Cons}}; &
            \completebinaryleaftreedepthtwo{$0$}{$1$}{$2$}{$3$} &
            \\
        };
        \matrix (node2) [node_matrix, nodes = {minimum height = 40}] at (6, 0) {
            \node (node2-1-1) [align = left] {\coqinlinelight{Digital} \\ \coqinlinelight{List} \\ \coqinlinelight{Cons}}; &
            \O &
            \\
        };
        \matrix (node3) [node_matrix, nodes = {minimum height = 40}] at (10, 0) {
            \node (node3-1-1) [align = left] {\coqinlinelight{Digital} \\ \coqinlinelight{List} \\ \coqinlinelight{Cons}}; &
            \completebinaryleaftreedepthzero{$4$} &
            \\
        };
        \matrix (node4) [node_matrix, nodes = {minimum height = 40}] at (14, 0) {
            \node (node4-1-1) [align = left] {\coqinlinelight{Digital} \\ \coqinlinelight{List} \\ \coqinlinelight{Nil}}; \\
        };
        \draw [arrow] (node1-1-3.center) to (node2-1-1);
        \draw [arrow] (node2-1-3.center) to (node3-1-1);
        \draw [arrow] (node3-1-3.center) to (node4-1-1);
    \end{tikzpicture}
\end{no_padding_center}

Or, to simplify the drawing, the following notation will be used form now on:

\begin{no_padding_center}
    $\xbraces{
        \vcenter{\hbox{\completebinaryleaftreedepthtwo{$0$}{$1$}{$2$}{$3$}}},
        \vcenter{\hbox{\bigvarnothing}},
        \vcenter{\hbox{\completebinaryleaftreedepthzero{$4$}}}
    }$
\end{no_padding_center}

\subsection{Formal definitions}

The function \coqinline{to_digits : forall (d n : nat), list nat} gives the list of length \coqinline{d} consisting of digits of \coqinline{i} in big-endian ordering: for example, \coqinline{to_digits 8 73} gives \coqinline{[0; 1; 0; 0; 1; 0; 0; 1]}. The inverse operation is performed by \coqinline{from_digits : forall (d : nat) (nl : list nat), nat}: for example, \coqinline{from_digits 8 [0; 1; 0; 0; 1; 0; 0; 1]} gives \coqinline{73}.

The binary leaf tree, digits list and concrete digital list are defined as follows:

\begin{coq}
Inductive binary_leaf_tree {A} :=
  | BinaryLeafTreeLeaf : A -> binary_leaf_tree
  | BinaryLeafTreeInternalNode : binary_leaf_tree -> binary_leaf_tree -> binary_leaf_tree.

Arguments binary_leaf_tree : clear implicits.

Inductive digital_list {A} :=
  | DigitalListNil : digital_list
  | DigitalListCons : option (binary_leaf_tree A) -> digital_list -> digital_list.

Arguments digital_list : clear implicits.

Inductive concrete_digital_list {A} :=
  | ConcreteDigitalList : forall (d : nat), digital_list A -> concrete_digital_list.

Arguments concrete_digital_list : clear implicits.
\end{coq}

Next we will consider operations that we can do with these type. We will define each operation on binary leaf trees, then lift it to digital lists (always having a ``depth'' argument for consistency and for reasons outlined later, even when it is not actually used), and finally to concrete digital lists.

\subsection{Interpretation}

The first operation will be conversion to a simple list, which at the same times gives an ``interpretation'' of the data structures, allowing us to establish a convection between the operations on them and ones on the regular lists, which means proving their correctness.

To convert binary leaf tree to a list, we just traverse its leaves in their natural order.

Example input:

\begin{no_padding_center}
    \completebinaryleaftreedepthtwo{$0$}{$1$}{$2$}{$3$}
\end{no_padding_center}

Example output:

\begin{no_padding_center}
    \begin{tikzpicture}
        \matrix (node1) [node_matrix] at (0, 0) {
            \coqinlinelight{cons} &
            0 &
            \\
        };
        \matrix (node2) [node_matrix] at (3, 0) {
            \coqinlinelight{cons} &
            1 &
            \\
        };
        \matrix (node3) [node_matrix] at (6, 0) {
            \coqinlinelight{cons} &
            2 &
            \\
        };
        \matrix (node4) [node_matrix] at (9, 0) {
            \coqinlinelight{cons} &
            3 &
            \\
        };
        \matrix (node5) [node_matrix] at (12, 0) {
            \coqinlinelight{nil} \\
        };
        \draw [arrow] (node1-1-3.center) to (node2-1-1);
        \draw [arrow] (node2-1-3.center) to (node3-1-1);
        \draw [arrow] (node3-1-3.center) to (node4-1-1);
        \draw [arrow] (node4-1-3.center) to (node5-1-1);
    \end{tikzpicture}
\end{no_padding_center}

\begin{coq}
Fixpoint binary_leaf_tree_to_list {A} (blt : binary_leaf_tree A) :=
  match blt with
  | BinaryLeafTreeLeaf x => [x]
  | BinaryLeafTreeInternalNode blt'1 blt'2 =>
    binary_leaf_tree_to_list blt'1 ++ binary_leaf_tree_to_list blt'2
  end.
\end{coq}

\begin{coq}
Fixpoint digital_list_to_list {A} d (dl : digital_list A) :=
  match dl with
  | DigitalListNil => []
  | DigitalListCons o dl' =>
    match o with
    | None => []
    | Some blt => binary_leaf_tree_to_list blt
    end ++ digital_list_to_list (pred d) dl'
  end.

Definition concrete_digital_list_to_list {A} (cdl : concrete_digital_list A) :=
  let '(ConcreteDigitalList d dl) := cdl in digital_list_to_list d dl.
\end{coq}

\printbibliography

\end{document}
